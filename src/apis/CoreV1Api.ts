/* tslint:disable */
/* eslint-disable */
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.18.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    V1APIResourceList,
    V1APIResourceListFromJSON,
    V1APIResourceListToJSON,
    V1Binding,
    V1BindingFromJSON,
    V1BindingToJSON,
    V1ComponentStatus,
    V1ComponentStatusFromJSON,
    V1ComponentStatusToJSON,
    V1ComponentStatusList,
    V1ComponentStatusListFromJSON,
    V1ComponentStatusListToJSON,
    V1ConfigMap,
    V1ConfigMapFromJSON,
    V1ConfigMapToJSON,
    V1ConfigMapList,
    V1ConfigMapListFromJSON,
    V1ConfigMapListToJSON,
    V1DeleteOptions,
    V1DeleteOptionsFromJSON,
    V1DeleteOptionsToJSON,
    V1Endpoints,
    V1EndpointsFromJSON,
    V1EndpointsToJSON,
    V1EndpointsList,
    V1EndpointsListFromJSON,
    V1EndpointsListToJSON,
    V1Event,
    V1EventFromJSON,
    V1EventToJSON,
    V1EventList,
    V1EventListFromJSON,
    V1EventListToJSON,
    V1LimitRange,
    V1LimitRangeFromJSON,
    V1LimitRangeToJSON,
    V1LimitRangeList,
    V1LimitRangeListFromJSON,
    V1LimitRangeListToJSON,
    V1Namespace,
    V1NamespaceFromJSON,
    V1NamespaceToJSON,
    V1NamespaceList,
    V1NamespaceListFromJSON,
    V1NamespaceListToJSON,
    V1Node,
    V1NodeFromJSON,
    V1NodeToJSON,
    V1NodeList,
    V1NodeListFromJSON,
    V1NodeListToJSON,
    V1PersistentVolume,
    V1PersistentVolumeFromJSON,
    V1PersistentVolumeToJSON,
    V1PersistentVolumeClaim,
    V1PersistentVolumeClaimFromJSON,
    V1PersistentVolumeClaimToJSON,
    V1PersistentVolumeClaimList,
    V1PersistentVolumeClaimListFromJSON,
    V1PersistentVolumeClaimListToJSON,
    V1PersistentVolumeList,
    V1PersistentVolumeListFromJSON,
    V1PersistentVolumeListToJSON,
    V1Pod,
    V1PodFromJSON,
    V1PodToJSON,
    V1PodList,
    V1PodListFromJSON,
    V1PodListToJSON,
    V1PodTemplate,
    V1PodTemplateFromJSON,
    V1PodTemplateToJSON,
    V1PodTemplateList,
    V1PodTemplateListFromJSON,
    V1PodTemplateListToJSON,
    V1ReplicationController,
    V1ReplicationControllerFromJSON,
    V1ReplicationControllerToJSON,
    V1ReplicationControllerList,
    V1ReplicationControllerListFromJSON,
    V1ReplicationControllerListToJSON,
    V1ResourceQuota,
    V1ResourceQuotaFromJSON,
    V1ResourceQuotaToJSON,
    V1ResourceQuotaList,
    V1ResourceQuotaListFromJSON,
    V1ResourceQuotaListToJSON,
    V1Scale,
    V1ScaleFromJSON,
    V1ScaleToJSON,
    V1Secret,
    V1SecretFromJSON,
    V1SecretToJSON,
    V1SecretList,
    V1SecretListFromJSON,
    V1SecretListToJSON,
    V1Service,
    V1ServiceFromJSON,
    V1ServiceToJSON,
    V1ServiceAccount,
    V1ServiceAccountFromJSON,
    V1ServiceAccountToJSON,
    V1ServiceAccountList,
    V1ServiceAccountListFromJSON,
    V1ServiceAccountListToJSON,
    V1ServiceList,
    V1ServiceListFromJSON,
    V1ServiceListToJSON,
    V1Status,
    V1StatusFromJSON,
    V1StatusToJSON,
    V1beta1Eviction,
    V1beta1EvictionFromJSON,
    V1beta1EvictionToJSON,
} from '../models';

export interface ConnectDeleteNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectDeleteNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectDeleteNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectDeleteNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectDeleteNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectDeleteNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectGetNamespacedPodAttachRequest {
    name: string;
    namespace: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectGetNamespacedPodExecRequest {
    name: string;
    namespace: string;
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectGetNamespacedPodPortforwardRequest {
    name: string;
    namespace: string;
    ports?: number;
}

export interface ConnectGetNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectGetNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectGetNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectGetNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectGetNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectGetNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectHeadNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectHeadNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectHeadNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectHeadNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectHeadNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectHeadNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectOptionsNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectOptionsNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectOptionsNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectOptionsNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectOptionsNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectOptionsNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectPatchNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectPatchNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectPatchNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectPatchNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectPatchNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectPatchNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectPostNamespacedPodAttachRequest {
    name: string;
    namespace: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectPostNamespacedPodExecRequest {
    name: string;
    namespace: string;
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectPostNamespacedPodPortforwardRequest {
    name: string;
    namespace: string;
    ports?: number;
}

export interface ConnectPostNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectPostNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectPostNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectPostNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectPostNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectPostNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectPutNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectPutNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectPutNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectPutNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectPutNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectPutNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface CreateNamespaceRequest {
    body: V1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedBindingRequest {
    namespace: string;
    body: V1Binding;
    dryRun?: string;
    fieldManager?: string;
    pretty?: string;
}

export interface CreateNamespacedConfigMapRequest {
    namespace: string;
    body: V1ConfigMap;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedEndpointsRequest {
    namespace: string;
    body: V1Endpoints;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedEventRequest {
    namespace: string;
    body: V1Event;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedLimitRangeRequest {
    namespace: string;
    body: V1LimitRange;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedPersistentVolumeClaimRequest {
    namespace: string;
    body: V1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedPodRequest {
    namespace: string;
    body: V1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedPodBindingRequest {
    name: string;
    namespace: string;
    body: V1Binding;
    dryRun?: string;
    fieldManager?: string;
    pretty?: string;
}

export interface CreateNamespacedPodEvictionRequest {
    name: string;
    namespace: string;
    body: V1beta1Eviction;
    dryRun?: string;
    fieldManager?: string;
    pretty?: string;
}

export interface CreateNamespacedPodTemplateRequest {
    namespace: string;
    body: V1PodTemplate;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedReplicationControllerRequest {
    namespace: string;
    body: V1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedResourceQuotaRequest {
    namespace: string;
    body: V1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedSecretRequest {
    namespace: string;
    body: V1Secret;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedServiceRequest {
    namespace: string;
    body: V1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNamespacedServiceAccountRequest {
    namespace: string;
    body: V1ServiceAccount;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateNodeRequest {
    body: V1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreatePersistentVolumeRequest {
    body: V1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface DeleteCollectionNamespacedConfigMapRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNamespacedEndpointsRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNamespacedEventRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNamespacedLimitRangeRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNamespacedPersistentVolumeClaimRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNamespacedPodRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNamespacedPodTemplateRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNamespacedReplicationControllerRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNamespacedResourceQuotaRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNamespacedSecretRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNamespacedServiceAccountRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionNodeRequest {
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteCollectionPersistentVolumeRequest {
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface DeleteNamespaceRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedConfigMapRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedEndpointsRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedEventRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedPodRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedSecretRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedServiceRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeleteNodeRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface DeletePersistentVolumeRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface ListComponentStatusRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListConfigMapForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListEndpointsForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListEventForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListLimitRangeForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespaceRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedConfigMapRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedEndpointsRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedEventRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedLimitRangeRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedPersistentVolumeClaimRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedPodRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedPodTemplateRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedReplicationControllerRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedResourceQuotaRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedSecretRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedServiceRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNamespacedServiceAccountRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListNodeRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListPersistentVolumeRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListPersistentVolumeClaimForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListPodForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListPodTemplateForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListReplicationControllerForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListResourceQuotaForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListSecretForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListServiceAccountForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListServiceForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface PatchNamespaceRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespaceStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedConfigMapRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedEndpointsRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedEventRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedPodRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedPodStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedSecretRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedServiceRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNodeRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchNodeStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchPersistentVolumeRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchPersistentVolumeStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface ReadComponentStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReadNamespaceRequest {
    name: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespaceStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReadNamespacedConfigMapRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedEndpointsRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedEventRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadNamespacedPodRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedPodLogRequest {
    name: string;
    namespace: string;
    container?: string;
    follow?: boolean;
    insecureSkipTLSVerifyBackend?: boolean;
    limitBytes?: number;
    pretty?: string;
    previous?: boolean;
    sinceSeconds?: number;
    tailLines?: number;
    timestamps?: boolean;
}

export interface ReadNamespacedPodStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadNamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadNamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadNamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadNamespacedSecretRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedServiceRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadNodeRequest {
    name: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadNodeStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReadPersistentVolumeRequest {
    name: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadPersistentVolumeStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReplaceNamespaceRequest {
    name: string;
    body: V1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespaceFinalizeRequest {
    name: string;
    body: V1Namespace;
    dryRun?: string;
    fieldManager?: string;
    pretty?: string;
}

export interface ReplaceNamespaceStatusRequest {
    name: string;
    body: V1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedConfigMapRequest {
    name: string;
    namespace: string;
    body: V1ConfigMap;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedEndpointsRequest {
    name: string;
    namespace: string;
    body: V1Endpoints;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedEventRequest {
    name: string;
    namespace: string;
    body: V1Event;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    body: V1LimitRange;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    body: V1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    body: V1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedPodRequest {
    name: string;
    namespace: string;
    body: V1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedPodStatusRequest {
    name: string;
    namespace: string;
    body: V1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    body: V1PodTemplate;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    body: V1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    body: V1Scale;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    body: V1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    body: V1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    body: V1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedSecretRequest {
    name: string;
    namespace: string;
    body: V1Secret;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedServiceRequest {
    name: string;
    namespace: string;
    body: V1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    body: V1ServiceAccount;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    body: V1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNodeRequest {
    name: string;
    body: V1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceNodeStatusRequest {
    name: string;
    body: V1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplacePersistentVolumeRequest {
    name: string;
    body: V1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplacePersistentVolumeStatusRequest {
    name: string;
    body: V1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

/**
 * 
 */
export class CoreV1Api extends runtime.BaseAPI {

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectDeleteNamespacedPodProxyRaw(requestParameters: ConnectDeleteNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectDeleteNamespacedPodProxy(requestParameters: ConnectDeleteNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectDeleteNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectDeleteNamespacedPodProxyWithPathRaw(requestParameters: ConnectDeleteNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectDeleteNamespacedPodProxyWithPath(requestParameters: ConnectDeleteNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectDeleteNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectDeleteNamespacedServiceProxyRaw(requestParameters: ConnectDeleteNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectDeleteNamespacedServiceProxy(requestParameters: ConnectDeleteNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectDeleteNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectDeleteNamespacedServiceProxyWithPathRaw(requestParameters: ConnectDeleteNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectDeleteNamespacedServiceProxyWithPath(requestParameters: ConnectDeleteNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectDeleteNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectDeleteNodeProxyRaw(requestParameters: ConnectDeleteNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectDeleteNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectDeleteNodeProxy(requestParameters: ConnectDeleteNodeProxyRequest): Promise<string> {
        const response = await this.connectDeleteNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectDeleteNodeProxyWithPathRaw(requestParameters: ConnectDeleteNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectDeleteNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectDeleteNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectDeleteNodeProxyWithPath(requestParameters: ConnectDeleteNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectDeleteNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to attach of Pod
     */
    async connectGetNamespacedPodAttachRaw(requestParameters: ConnectGetNamespacedPodAttachRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodAttach.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodAttach.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to attach of Pod
     */
    async connectGetNamespacedPodAttach(requestParameters: ConnectGetNamespacedPodAttachRequest): Promise<string> {
        const response = await this.connectGetNamespacedPodAttachRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to exec of Pod
     */
    async connectGetNamespacedPodExecRaw(requestParameters: ConnectGetNamespacedPodExecRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodExec.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodExec.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.command !== undefined) {
            queryParameters['command'] = requestParameters.command;
        }

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to exec of Pod
     */
    async connectGetNamespacedPodExec(requestParameters: ConnectGetNamespacedPodExecRequest): Promise<string> {
        const response = await this.connectGetNamespacedPodExecRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to portforward of Pod
     */
    async connectGetNamespacedPodPortforwardRaw(requestParameters: ConnectGetNamespacedPodPortforwardRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodPortforward.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodPortforward.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.ports !== undefined) {
            queryParameters['ports'] = requestParameters.ports;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to portforward of Pod
     */
    async connectGetNamespacedPodPortforward(requestParameters: ConnectGetNamespacedPodPortforwardRequest): Promise<string> {
        const response = await this.connectGetNamespacedPodPortforwardRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectGetNamespacedPodProxyRaw(requestParameters: ConnectGetNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectGetNamespacedPodProxy(requestParameters: ConnectGetNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectGetNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectGetNamespacedPodProxyWithPathRaw(requestParameters: ConnectGetNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectGetNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectGetNamespacedPodProxyWithPath(requestParameters: ConnectGetNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectGetNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectGetNamespacedServiceProxyRaw(requestParameters: ConnectGetNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectGetNamespacedServiceProxy(requestParameters: ConnectGetNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectGetNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectGetNamespacedServiceProxyWithPathRaw(requestParameters: ConnectGetNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectGetNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectGetNamespacedServiceProxyWithPath(requestParameters: ConnectGetNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectGetNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectGetNodeProxyRaw(requestParameters: ConnectGetNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectGetNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectGetNodeProxy(requestParameters: ConnectGetNodeProxyRequest): Promise<string> {
        const response = await this.connectGetNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectGetNodeProxyWithPathRaw(requestParameters: ConnectGetNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectGetNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectGetNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectGetNodeProxyWithPath(requestParameters: ConnectGetNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectGetNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectHeadNamespacedPodProxyRaw(requestParameters: ConnectHeadNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectHeadNamespacedPodProxy(requestParameters: ConnectHeadNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectHeadNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectHeadNamespacedPodProxyWithPathRaw(requestParameters: ConnectHeadNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectHeadNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectHeadNamespacedPodProxyWithPath(requestParameters: ConnectHeadNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectHeadNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectHeadNamespacedServiceProxyRaw(requestParameters: ConnectHeadNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectHeadNamespacedServiceProxy(requestParameters: ConnectHeadNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectHeadNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectHeadNamespacedServiceProxyWithPathRaw(requestParameters: ConnectHeadNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectHeadNamespacedServiceProxyWithPath(requestParameters: ConnectHeadNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectHeadNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectHeadNodeProxyRaw(requestParameters: ConnectHeadNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectHeadNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectHeadNodeProxy(requestParameters: ConnectHeadNodeProxyRequest): Promise<string> {
        const response = await this.connectHeadNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectHeadNodeProxyWithPathRaw(requestParameters: ConnectHeadNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectHeadNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectHeadNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectHeadNodeProxyWithPath(requestParameters: ConnectHeadNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectHeadNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectOptionsNamespacedPodProxyRaw(requestParameters: ConnectOptionsNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectOptionsNamespacedPodProxy(requestParameters: ConnectOptionsNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectOptionsNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectOptionsNamespacedPodProxyWithPathRaw(requestParameters: ConnectOptionsNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectOptionsNamespacedPodProxyWithPath(requestParameters: ConnectOptionsNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectOptionsNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectOptionsNamespacedServiceProxyRaw(requestParameters: ConnectOptionsNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectOptionsNamespacedServiceProxy(requestParameters: ConnectOptionsNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectOptionsNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectOptionsNamespacedServiceProxyWithPathRaw(requestParameters: ConnectOptionsNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectOptionsNamespacedServiceProxyWithPath(requestParameters: ConnectOptionsNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectOptionsNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectOptionsNodeProxyRaw(requestParameters: ConnectOptionsNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectOptionsNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectOptionsNodeProxy(requestParameters: ConnectOptionsNodeProxyRequest): Promise<string> {
        const response = await this.connectOptionsNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectOptionsNodeProxyWithPathRaw(requestParameters: ConnectOptionsNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectOptionsNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectOptionsNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectOptionsNodeProxyWithPath(requestParameters: ConnectOptionsNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectOptionsNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectPatchNamespacedPodProxyRaw(requestParameters: ConnectPatchNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectPatchNamespacedPodProxy(requestParameters: ConnectPatchNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectPatchNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectPatchNamespacedPodProxyWithPathRaw(requestParameters: ConnectPatchNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectPatchNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectPatchNamespacedPodProxyWithPath(requestParameters: ConnectPatchNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectPatchNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectPatchNamespacedServiceProxyRaw(requestParameters: ConnectPatchNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectPatchNamespacedServiceProxy(requestParameters: ConnectPatchNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectPatchNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectPatchNamespacedServiceProxyWithPathRaw(requestParameters: ConnectPatchNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectPatchNamespacedServiceProxyWithPath(requestParameters: ConnectPatchNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectPatchNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectPatchNodeProxyRaw(requestParameters: ConnectPatchNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPatchNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectPatchNodeProxy(requestParameters: ConnectPatchNodeProxyRequest): Promise<string> {
        const response = await this.connectPatchNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectPatchNodeProxyWithPathRaw(requestParameters: ConnectPatchNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPatchNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectPatchNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectPatchNodeProxyWithPath(requestParameters: ConnectPatchNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectPatchNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to attach of Pod
     */
    async connectPostNamespacedPodAttachRaw(requestParameters: ConnectPostNamespacedPodAttachRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodAttach.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodAttach.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to attach of Pod
     */
    async connectPostNamespacedPodAttach(requestParameters: ConnectPostNamespacedPodAttachRequest): Promise<string> {
        const response = await this.connectPostNamespacedPodAttachRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to exec of Pod
     */
    async connectPostNamespacedPodExecRaw(requestParameters: ConnectPostNamespacedPodExecRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodExec.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodExec.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.command !== undefined) {
            queryParameters['command'] = requestParameters.command;
        }

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to exec of Pod
     */
    async connectPostNamespacedPodExec(requestParameters: ConnectPostNamespacedPodExecRequest): Promise<string> {
        const response = await this.connectPostNamespacedPodExecRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to portforward of Pod
     */
    async connectPostNamespacedPodPortforwardRaw(requestParameters: ConnectPostNamespacedPodPortforwardRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodPortforward.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodPortforward.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.ports !== undefined) {
            queryParameters['ports'] = requestParameters.ports;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to portforward of Pod
     */
    async connectPostNamespacedPodPortforward(requestParameters: ConnectPostNamespacedPodPortforwardRequest): Promise<string> {
        const response = await this.connectPostNamespacedPodPortforwardRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectPostNamespacedPodProxyRaw(requestParameters: ConnectPostNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectPostNamespacedPodProxy(requestParameters: ConnectPostNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectPostNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectPostNamespacedPodProxyWithPathRaw(requestParameters: ConnectPostNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectPostNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectPostNamespacedPodProxyWithPath(requestParameters: ConnectPostNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectPostNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectPostNamespacedServiceProxyRaw(requestParameters: ConnectPostNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectPostNamespacedServiceProxy(requestParameters: ConnectPostNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectPostNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectPostNamespacedServiceProxyWithPathRaw(requestParameters: ConnectPostNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectPostNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectPostNamespacedServiceProxyWithPath(requestParameters: ConnectPostNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectPostNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectPostNodeProxyRaw(requestParameters: ConnectPostNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPostNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectPostNodeProxy(requestParameters: ConnectPostNodeProxyRequest): Promise<string> {
        const response = await this.connectPostNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectPostNodeProxyWithPathRaw(requestParameters: ConnectPostNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPostNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectPostNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectPostNodeProxyWithPath(requestParameters: ConnectPostNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectPostNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectPutNamespacedPodProxyRaw(requestParameters: ConnectPutNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectPutNamespacedPodProxy(requestParameters: ConnectPutNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectPutNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectPutNamespacedPodProxyWithPathRaw(requestParameters: ConnectPutNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectPutNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectPutNamespacedPodProxyWithPath(requestParameters: ConnectPutNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectPutNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectPutNamespacedServiceProxyRaw(requestParameters: ConnectPutNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectPutNamespacedServiceProxy(requestParameters: ConnectPutNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectPutNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectPutNamespacedServiceProxyWithPathRaw(requestParameters: ConnectPutNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectPutNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectPutNamespacedServiceProxyWithPath(requestParameters: ConnectPutNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectPutNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectPutNodeProxyRaw(requestParameters: ConnectPutNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPutNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectPutNodeProxy(requestParameters: ConnectPutNodeProxyRequest): Promise<string> {
        const response = await this.connectPutNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectPutNodeProxyWithPathRaw(requestParameters: ConnectPutNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectPutNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectPutNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectPutNodeProxyWithPath(requestParameters: ConnectPutNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectPutNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Namespace
     */
    async createNamespaceRaw(requestParameters: CreateNamespaceRequest): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1NamespaceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * create a Namespace
     */
    async createNamespace(requestParameters: CreateNamespaceRequest): Promise<V1Namespace> {
        const response = await this.createNamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Binding
     */
    async createNamespacedBindingRaw(requestParameters: CreateNamespacedBindingRequest): Promise<runtime.ApiResponse<V1Binding>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedBinding.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedBinding.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/bindings`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1BindingToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1BindingFromJSON(jsonValue));
    }

    /**
     * create a Binding
     */
    async createNamespacedBinding(requestParameters: CreateNamespacedBindingRequest): Promise<V1Binding> {
        const response = await this.createNamespacedBindingRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a ConfigMap
     */
    async createNamespacedConfigMapRaw(requestParameters: CreateNamespacedConfigMapRequest): Promise<runtime.ApiResponse<V1ConfigMap>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedConfigMap.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1ConfigMapToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapFromJSON(jsonValue));
    }

    /**
     * create a ConfigMap
     */
    async createNamespacedConfigMap(requestParameters: CreateNamespacedConfigMapRequest): Promise<V1ConfigMap> {
        const response = await this.createNamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * create Endpoints
     */
    async createNamespacedEndpointsRaw(requestParameters: CreateNamespacedEndpointsRequest): Promise<runtime.ApiResponse<V1Endpoints>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedEndpoints.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1EndpointsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsFromJSON(jsonValue));
    }

    /**
     * create Endpoints
     */
    async createNamespacedEndpoints(requestParameters: CreateNamespacedEndpointsRequest): Promise<V1Endpoints> {
        const response = await this.createNamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * create an Event
     */
    async createNamespacedEventRaw(requestParameters: CreateNamespacedEventRequest): Promise<runtime.ApiResponse<V1Event>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedEvent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1EventToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EventFromJSON(jsonValue));
    }

    /**
     * create an Event
     */
    async createNamespacedEvent(requestParameters: CreateNamespacedEventRequest): Promise<V1Event> {
        const response = await this.createNamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a LimitRange
     */
    async createNamespacedLimitRangeRaw(requestParameters: CreateNamespacedLimitRangeRequest): Promise<runtime.ApiResponse<V1LimitRange>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedLimitRange.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1LimitRangeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeFromJSON(jsonValue));
    }

    /**
     * create a LimitRange
     */
    async createNamespacedLimitRange(requestParameters: CreateNamespacedLimitRangeRequest): Promise<V1LimitRange> {
        const response = await this.createNamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a PersistentVolumeClaim
     */
    async createNamespacedPersistentVolumeClaimRaw(requestParameters: CreateNamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeClaimToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * create a PersistentVolumeClaim
     */
    async createNamespacedPersistentVolumeClaim(requestParameters: CreateNamespacedPersistentVolumeClaimRequest): Promise<V1PersistentVolumeClaim> {
        const response = await this.createNamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Pod
     */
    async createNamespacedPodRaw(requestParameters: CreateNamespacedPodRequest): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPod.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * create a Pod
     */
    async createNamespacedPod(requestParameters: CreateNamespacedPodRequest): Promise<V1Pod> {
        const response = await this.createNamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * create binding of a Pod
     */
    async createNamespacedPodBindingRaw(requestParameters: CreateNamespacedPodBindingRequest): Promise<runtime.ApiResponse<V1Binding>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createNamespacedPodBinding.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPodBinding.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedPodBinding.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/binding`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1BindingToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1BindingFromJSON(jsonValue));
    }

    /**
     * create binding of a Pod
     */
    async createNamespacedPodBinding(requestParameters: CreateNamespacedPodBindingRequest): Promise<V1Binding> {
        const response = await this.createNamespacedPodBindingRaw(requestParameters);
        return await response.value();
    }

    /**
     * create eviction of a Pod
     */
    async createNamespacedPodEvictionRaw(requestParameters: CreateNamespacedPodEvictionRequest): Promise<runtime.ApiResponse<V1beta1Eviction>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createNamespacedPodEviction.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPodEviction.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedPodEviction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/eviction`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1beta1EvictionToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1beta1EvictionFromJSON(jsonValue));
    }

    /**
     * create eviction of a Pod
     */
    async createNamespacedPodEviction(requestParameters: CreateNamespacedPodEvictionRequest): Promise<V1beta1Eviction> {
        const response = await this.createNamespacedPodEvictionRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a PodTemplate
     */
    async createNamespacedPodTemplateRaw(requestParameters: CreateNamespacedPodTemplateRequest): Promise<runtime.ApiResponse<V1PodTemplate>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPodTemplate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodTemplateToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateFromJSON(jsonValue));
    }

    /**
     * create a PodTemplate
     */
    async createNamespacedPodTemplate(requestParameters: CreateNamespacedPodTemplateRequest): Promise<V1PodTemplate> {
        const response = await this.createNamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a ReplicationController
     */
    async createNamespacedReplicationControllerRaw(requestParameters: CreateNamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedReplicationController.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1ReplicationControllerToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * create a ReplicationController
     */
    async createNamespacedReplicationController(requestParameters: CreateNamespacedReplicationControllerRequest): Promise<V1ReplicationController> {
        const response = await this.createNamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a ResourceQuota
     */
    async createNamespacedResourceQuotaRaw(requestParameters: CreateNamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedResourceQuota.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1ResourceQuotaToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * create a ResourceQuota
     */
    async createNamespacedResourceQuota(requestParameters: CreateNamespacedResourceQuotaRequest): Promise<V1ResourceQuota> {
        const response = await this.createNamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Secret
     */
    async createNamespacedSecretRaw(requestParameters: CreateNamespacedSecretRequest): Promise<runtime.ApiResponse<V1Secret>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1SecretToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretFromJSON(jsonValue));
    }

    /**
     * create a Secret
     */
    async createNamespacedSecret(requestParameters: CreateNamespacedSecretRequest): Promise<V1Secret> {
        const response = await this.createNamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Service
     */
    async createNamespacedServiceRaw(requestParameters: CreateNamespacedServiceRequest): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedService.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1ServiceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * create a Service
     */
    async createNamespacedService(requestParameters: CreateNamespacedServiceRequest): Promise<V1Service> {
        const response = await this.createNamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a ServiceAccount
     */
    async createNamespacedServiceAccountRaw(requestParameters: CreateNamespacedServiceAccountRequest): Promise<runtime.ApiResponse<V1ServiceAccount>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createNamespacedServiceAccount.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1ServiceAccountToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * create a ServiceAccount
     */
    async createNamespacedServiceAccount(requestParameters: CreateNamespacedServiceAccountRequest): Promise<V1ServiceAccount> {
        const response = await this.createNamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Node
     */
    async createNodeRaw(requestParameters: CreateNodeRequest): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createNode.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1NodeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * create a Node
     */
    async createNode(requestParameters: CreateNodeRequest): Promise<V1Node> {
        const response = await this.createNodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a PersistentVolume
     */
    async createPersistentVolumeRaw(requestParameters: CreatePersistentVolumeRequest): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createPersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * create a PersistentVolume
     */
    async createPersistentVolume(requestParameters: CreatePersistentVolumeRequest): Promise<V1PersistentVolume> {
        const response = await this.createPersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of ConfigMap
     */
    async deleteCollectionNamespacedConfigMapRaw(requestParameters: DeleteCollectionNamespacedConfigMapRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ConfigMap
     */
    async deleteCollectionNamespacedConfigMap(requestParameters: DeleteCollectionNamespacedConfigMapRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of Endpoints
     */
    async deleteCollectionNamespacedEndpointsRaw(requestParameters: DeleteCollectionNamespacedEndpointsRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Endpoints
     */
    async deleteCollectionNamespacedEndpoints(requestParameters: DeleteCollectionNamespacedEndpointsRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of Event
     */
    async deleteCollectionNamespacedEventRaw(requestParameters: DeleteCollectionNamespacedEventRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Event
     */
    async deleteCollectionNamespacedEvent(requestParameters: DeleteCollectionNamespacedEventRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of LimitRange
     */
    async deleteCollectionNamespacedLimitRangeRaw(requestParameters: DeleteCollectionNamespacedLimitRangeRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of LimitRange
     */
    async deleteCollectionNamespacedLimitRange(requestParameters: DeleteCollectionNamespacedLimitRangeRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of PersistentVolumeClaim
     */
    async deleteCollectionNamespacedPersistentVolumeClaimRaw(requestParameters: DeleteCollectionNamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PersistentVolumeClaim
     */
    async deleteCollectionNamespacedPersistentVolumeClaim(requestParameters: DeleteCollectionNamespacedPersistentVolumeClaimRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of Pod
     */
    async deleteCollectionNamespacedPodRaw(requestParameters: DeleteCollectionNamespacedPodRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Pod
     */
    async deleteCollectionNamespacedPod(requestParameters: DeleteCollectionNamespacedPodRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of PodTemplate
     */
    async deleteCollectionNamespacedPodTemplateRaw(requestParameters: DeleteCollectionNamespacedPodTemplateRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PodTemplate
     */
    async deleteCollectionNamespacedPodTemplate(requestParameters: DeleteCollectionNamespacedPodTemplateRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of ReplicationController
     */
    async deleteCollectionNamespacedReplicationControllerRaw(requestParameters: DeleteCollectionNamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ReplicationController
     */
    async deleteCollectionNamespacedReplicationController(requestParameters: DeleteCollectionNamespacedReplicationControllerRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of ResourceQuota
     */
    async deleteCollectionNamespacedResourceQuotaRaw(requestParameters: DeleteCollectionNamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ResourceQuota
     */
    async deleteCollectionNamespacedResourceQuota(requestParameters: DeleteCollectionNamespacedResourceQuotaRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of Secret
     */
    async deleteCollectionNamespacedSecretRaw(requestParameters: DeleteCollectionNamespacedSecretRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Secret
     */
    async deleteCollectionNamespacedSecret(requestParameters: DeleteCollectionNamespacedSecretRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of ServiceAccount
     */
    async deleteCollectionNamespacedServiceAccountRaw(requestParameters: DeleteCollectionNamespacedServiceAccountRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ServiceAccount
     */
    async deleteCollectionNamespacedServiceAccount(requestParameters: DeleteCollectionNamespacedServiceAccountRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of Node
     */
    async deleteCollectionNodeRaw(requestParameters: DeleteCollectionNodeRequest): Promise<runtime.ApiResponse<V1Status>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Node
     */
    async deleteCollectionNode(requestParameters: DeleteCollectionNodeRequest): Promise<V1Status> {
        const response = await this.deleteCollectionNodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of PersistentVolume
     */
    async deleteCollectionPersistentVolumeRaw(requestParameters: DeleteCollectionPersistentVolumeRequest): Promise<runtime.ApiResponse<V1Status>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PersistentVolume
     */
    async deleteCollectionPersistentVolume(requestParameters: DeleteCollectionPersistentVolumeRequest): Promise<V1Status> {
        const response = await this.deleteCollectionPersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a Namespace
     */
    async deleteNamespaceRaw(requestParameters: DeleteNamespaceRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Namespace
     */
    async deleteNamespace(requestParameters: DeleteNamespaceRequest): Promise<V1Status> {
        const response = await this.deleteNamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a ConfigMap
     */
    async deleteNamespacedConfigMapRaw(requestParameters: DeleteNamespacedConfigMapRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a ConfigMap
     */
    async deleteNamespacedConfigMap(requestParameters: DeleteNamespacedConfigMapRequest): Promise<V1Status> {
        const response = await this.deleteNamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete Endpoints
     */
    async deleteNamespacedEndpointsRaw(requestParameters: DeleteNamespacedEndpointsRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete Endpoints
     */
    async deleteNamespacedEndpoints(requestParameters: DeleteNamespacedEndpointsRequest): Promise<V1Status> {
        const response = await this.deleteNamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete an Event
     */
    async deleteNamespacedEventRaw(requestParameters: DeleteNamespacedEventRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete an Event
     */
    async deleteNamespacedEvent(requestParameters: DeleteNamespacedEventRequest): Promise<V1Status> {
        const response = await this.deleteNamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a LimitRange
     */
    async deleteNamespacedLimitRangeRaw(requestParameters: DeleteNamespacedLimitRangeRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a LimitRange
     */
    async deleteNamespacedLimitRange(requestParameters: DeleteNamespacedLimitRangeRequest): Promise<V1Status> {
        const response = await this.deleteNamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a PersistentVolumeClaim
     */
    async deleteNamespacedPersistentVolumeClaimRaw(requestParameters: DeleteNamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * delete a PersistentVolumeClaim
     */
    async deleteNamespacedPersistentVolumeClaim(requestParameters: DeleteNamespacedPersistentVolumeClaimRequest): Promise<V1PersistentVolumeClaim> {
        const response = await this.deleteNamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a Pod
     */
    async deleteNamespacedPodRaw(requestParameters: DeleteNamespacedPodRequest): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * delete a Pod
     */
    async deleteNamespacedPod(requestParameters: DeleteNamespacedPodRequest): Promise<V1Pod> {
        const response = await this.deleteNamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a PodTemplate
     */
    async deleteNamespacedPodTemplateRaw(requestParameters: DeleteNamespacedPodTemplateRequest): Promise<runtime.ApiResponse<V1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateFromJSON(jsonValue));
    }

    /**
     * delete a PodTemplate
     */
    async deleteNamespacedPodTemplate(requestParameters: DeleteNamespacedPodTemplateRequest): Promise<V1PodTemplate> {
        const response = await this.deleteNamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a ReplicationController
     */
    async deleteNamespacedReplicationControllerRaw(requestParameters: DeleteNamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a ReplicationController
     */
    async deleteNamespacedReplicationController(requestParameters: DeleteNamespacedReplicationControllerRequest): Promise<V1Status> {
        const response = await this.deleteNamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a ResourceQuota
     */
    async deleteNamespacedResourceQuotaRaw(requestParameters: DeleteNamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * delete a ResourceQuota
     */
    async deleteNamespacedResourceQuota(requestParameters: DeleteNamespacedResourceQuotaRequest): Promise<V1ResourceQuota> {
        const response = await this.deleteNamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a Secret
     */
    async deleteNamespacedSecretRaw(requestParameters: DeleteNamespacedSecretRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Secret
     */
    async deleteNamespacedSecret(requestParameters: DeleteNamespacedSecretRequest): Promise<V1Status> {
        const response = await this.deleteNamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a Service
     */
    async deleteNamespacedServiceRaw(requestParameters: DeleteNamespacedServiceRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Service
     */
    async deleteNamespacedService(requestParameters: DeleteNamespacedServiceRequest): Promise<V1Status> {
        const response = await this.deleteNamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a ServiceAccount
     */
    async deleteNamespacedServiceAccountRaw(requestParameters: DeleteNamespacedServiceAccountRequest): Promise<runtime.ApiResponse<V1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * delete a ServiceAccount
     */
    async deleteNamespacedServiceAccount(requestParameters: DeleteNamespacedServiceAccountRequest): Promise<V1ServiceAccount> {
        const response = await this.deleteNamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a Node
     */
    async deleteNodeRaw(requestParameters: DeleteNodeRequest): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNode.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Node
     */
    async deleteNode(requestParameters: DeleteNodeRequest): Promise<V1Status> {
        const response = await this.deleteNodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a PersistentVolume
     */
    async deletePersistentVolumeRaw(requestParameters: DeletePersistentVolumeRequest): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deletePersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * delete a PersistentVolume
     */
    async deletePersistentVolume(requestParameters: DeletePersistentVolumeRequest): Promise<V1PersistentVolume> {
        const response = await this.deletePersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * get available resources
     */
    async getAPIResourcesRaw(): Promise<runtime.ApiResponse<V1APIResourceList>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1APIResourceListFromJSON(jsonValue));
    }

    /**
     * get available resources
     */
    async getAPIResources(): Promise<V1APIResourceList> {
        const response = await this.getAPIResourcesRaw();
        return await response.value();
    }

    /**
     * list objects of kind ComponentStatus
     */
    async listComponentStatusRaw(requestParameters: ListComponentStatusRequest): Promise<runtime.ApiResponse<V1ComponentStatusList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/componentstatuses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ComponentStatusListFromJSON(jsonValue));
    }

    /**
     * list objects of kind ComponentStatus
     */
    async listComponentStatus(requestParameters: ListComponentStatusRequest): Promise<V1ComponentStatusList> {
        const response = await this.listComponentStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listConfigMapForAllNamespacesRaw(requestParameters: ListConfigMapForAllNamespacesRequest): Promise<runtime.ApiResponse<V1ConfigMapList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/configmaps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listConfigMapForAllNamespaces(requestParameters: ListConfigMapForAllNamespacesRequest): Promise<V1ConfigMapList> {
        const response = await this.listConfigMapForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listEndpointsForAllNamespacesRaw(requestParameters: ListEndpointsForAllNamespacesRequest): Promise<runtime.ApiResponse<V1EndpointsList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/endpoints`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listEndpointsForAllNamespaces(requestParameters: ListEndpointsForAllNamespacesRequest): Promise<V1EndpointsList> {
        const response = await this.listEndpointsForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Event
     */
    async listEventForAllNamespacesRaw(requestParameters: ListEventForAllNamespacesRequest): Promise<runtime.ApiResponse<V1EventList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EventListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Event
     */
    async listEventForAllNamespaces(requestParameters: ListEventForAllNamespacesRequest): Promise<V1EventList> {
        const response = await this.listEventForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listLimitRangeForAllNamespacesRaw(requestParameters: ListLimitRangeForAllNamespacesRequest): Promise<runtime.ApiResponse<V1LimitRangeList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/limitranges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listLimitRangeForAllNamespaces(requestParameters: ListLimitRangeForAllNamespacesRequest): Promise<V1LimitRangeList> {
        const response = await this.listLimitRangeForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Namespace
     */
    async listNamespaceRaw(requestParameters: ListNamespaceRequest): Promise<runtime.ApiResponse<V1NamespaceList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Namespace
     */
    async listNamespace(requestParameters: ListNamespaceRequest): Promise<V1NamespaceList> {
        const response = await this.listNamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listNamespacedConfigMapRaw(requestParameters: ListNamespacedConfigMapRequest): Promise<runtime.ApiResponse<V1ConfigMapList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listNamespacedConfigMap(requestParameters: ListNamespacedConfigMapRequest): Promise<V1ConfigMapList> {
        const response = await this.listNamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listNamespacedEndpointsRaw(requestParameters: ListNamespacedEndpointsRequest): Promise<runtime.ApiResponse<V1EndpointsList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listNamespacedEndpoints(requestParameters: ListNamespacedEndpointsRequest): Promise<V1EndpointsList> {
        const response = await this.listNamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Event
     */
    async listNamespacedEventRaw(requestParameters: ListNamespacedEventRequest): Promise<runtime.ApiResponse<V1EventList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EventListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Event
     */
    async listNamespacedEvent(requestParameters: ListNamespacedEventRequest): Promise<V1EventList> {
        const response = await this.listNamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listNamespacedLimitRangeRaw(requestParameters: ListNamespacedLimitRangeRequest): Promise<runtime.ApiResponse<V1LimitRangeList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listNamespacedLimitRange(requestParameters: ListNamespacedLimitRangeRequest): Promise<V1LimitRangeList> {
        const response = await this.listNamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listNamespacedPersistentVolumeClaimRaw(requestParameters: ListNamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<V1PersistentVolumeClaimList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listNamespacedPersistentVolumeClaim(requestParameters: ListNamespacedPersistentVolumeClaimRequest): Promise<V1PersistentVolumeClaimList> {
        const response = await this.listNamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Pod
     */
    async listNamespacedPodRaw(requestParameters: ListNamespacedPodRequest): Promise<runtime.ApiResponse<V1PodList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Pod
     */
    async listNamespacedPod(requestParameters: ListNamespacedPodRequest): Promise<V1PodList> {
        const response = await this.listNamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listNamespacedPodTemplateRaw(requestParameters: ListNamespacedPodTemplateRequest): Promise<runtime.ApiResponse<V1PodTemplateList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listNamespacedPodTemplate(requestParameters: ListNamespacedPodTemplateRequest): Promise<V1PodTemplateList> {
        const response = await this.listNamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listNamespacedReplicationControllerRaw(requestParameters: ListNamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<V1ReplicationControllerList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listNamespacedReplicationController(requestParameters: ListNamespacedReplicationControllerRequest): Promise<V1ReplicationControllerList> {
        const response = await this.listNamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listNamespacedResourceQuotaRaw(requestParameters: ListNamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<V1ResourceQuotaList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listNamespacedResourceQuota(requestParameters: ListNamespacedResourceQuotaRequest): Promise<V1ResourceQuotaList> {
        const response = await this.listNamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Secret
     */
    async listNamespacedSecretRaw(requestParameters: ListNamespacedSecretRequest): Promise<runtime.ApiResponse<V1SecretList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Secret
     */
    async listNamespacedSecret(requestParameters: ListNamespacedSecretRequest): Promise<V1SecretList> {
        const response = await this.listNamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Service
     */
    async listNamespacedServiceRaw(requestParameters: ListNamespacedServiceRequest): Promise<runtime.ApiResponse<V1ServiceList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Service
     */
    async listNamespacedService(requestParameters: ListNamespacedServiceRequest): Promise<V1ServiceList> {
        const response = await this.listNamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listNamespacedServiceAccountRaw(requestParameters: ListNamespacedServiceAccountRequest): Promise<runtime.ApiResponse<V1ServiceAccountList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listNamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listNamespacedServiceAccount(requestParameters: ListNamespacedServiceAccountRequest): Promise<V1ServiceAccountList> {
        const response = await this.listNamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Node
     */
    async listNodeRaw(requestParameters: ListNodeRequest): Promise<runtime.ApiResponse<V1NodeList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Node
     */
    async listNode(requestParameters: ListNodeRequest): Promise<V1NodeList> {
        const response = await this.listNodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolume
     */
    async listPersistentVolumeRaw(requestParameters: ListPersistentVolumeRequest): Promise<runtime.ApiResponse<V1PersistentVolumeList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolume
     */
    async listPersistentVolume(requestParameters: ListPersistentVolumeRequest): Promise<V1PersistentVolumeList> {
        const response = await this.listPersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listPersistentVolumeClaimForAllNamespacesRaw(requestParameters: ListPersistentVolumeClaimForAllNamespacesRequest): Promise<runtime.ApiResponse<V1PersistentVolumeClaimList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumeclaims`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listPersistentVolumeClaimForAllNamespaces(requestParameters: ListPersistentVolumeClaimForAllNamespacesRequest): Promise<V1PersistentVolumeClaimList> {
        const response = await this.listPersistentVolumeClaimForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Pod
     */
    async listPodForAllNamespacesRaw(requestParameters: ListPodForAllNamespacesRequest): Promise<runtime.ApiResponse<V1PodList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/pods`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Pod
     */
    async listPodForAllNamespaces(requestParameters: ListPodForAllNamespacesRequest): Promise<V1PodList> {
        const response = await this.listPodForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listPodTemplateForAllNamespacesRaw(requestParameters: ListPodTemplateForAllNamespacesRequest): Promise<runtime.ApiResponse<V1PodTemplateList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/podtemplates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listPodTemplateForAllNamespaces(requestParameters: ListPodTemplateForAllNamespacesRequest): Promise<V1PodTemplateList> {
        const response = await this.listPodTemplateForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listReplicationControllerForAllNamespacesRaw(requestParameters: ListReplicationControllerForAllNamespacesRequest): Promise<runtime.ApiResponse<V1ReplicationControllerList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/replicationcontrollers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listReplicationControllerForAllNamespaces(requestParameters: ListReplicationControllerForAllNamespacesRequest): Promise<V1ReplicationControllerList> {
        const response = await this.listReplicationControllerForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listResourceQuotaForAllNamespacesRaw(requestParameters: ListResourceQuotaForAllNamespacesRequest): Promise<runtime.ApiResponse<V1ResourceQuotaList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/resourcequotas`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listResourceQuotaForAllNamespaces(requestParameters: ListResourceQuotaForAllNamespacesRequest): Promise<V1ResourceQuotaList> {
        const response = await this.listResourceQuotaForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Secret
     */
    async listSecretForAllNamespacesRaw(requestParameters: ListSecretForAllNamespacesRequest): Promise<runtime.ApiResponse<V1SecretList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/secrets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Secret
     */
    async listSecretForAllNamespaces(requestParameters: ListSecretForAllNamespacesRequest): Promise<V1SecretList> {
        const response = await this.listSecretForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listServiceAccountForAllNamespacesRaw(requestParameters: ListServiceAccountForAllNamespacesRequest): Promise<runtime.ApiResponse<V1ServiceAccountList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/serviceaccounts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listServiceAccountForAllNamespaces(requestParameters: ListServiceAccountForAllNamespacesRequest): Promise<V1ServiceAccountList> {
        const response = await this.listServiceAccountForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Service
     */
    async listServiceForAllNamespacesRaw(requestParameters: ListServiceForAllNamespacesRequest): Promise<runtime.ApiResponse<V1ServiceList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/services`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Service
     */
    async listServiceForAllNamespaces(requestParameters: ListServiceForAllNamespacesRequest): Promise<V1ServiceList> {
        const response = await this.listServiceForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Namespace
     */
    async patchNamespaceRaw(requestParameters: PatchNamespaceRequest): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespace.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * partially update the specified Namespace
     */
    async patchNamespace(requestParameters: PatchNamespaceRequest): Promise<V1Namespace> {
        const response = await this.patchNamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified Namespace
     */
    async patchNamespaceStatusRaw(requestParameters: PatchNamespaceStatusRequest): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespaceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespaceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Namespace
     */
    async patchNamespaceStatus(requestParameters: PatchNamespaceStatusRequest): Promise<V1Namespace> {
        const response = await this.patchNamespaceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified ConfigMap
     */
    async patchNamespacedConfigMapRaw(requestParameters: PatchNamespacedConfigMapRequest): Promise<runtime.ApiResponse<V1ConfigMap>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedConfigMap.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapFromJSON(jsonValue));
    }

    /**
     * partially update the specified ConfigMap
     */
    async patchNamespacedConfigMap(requestParameters: PatchNamespacedConfigMapRequest): Promise<V1ConfigMap> {
        const response = await this.patchNamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Endpoints
     */
    async patchNamespacedEndpointsRaw(requestParameters: PatchNamespacedEndpointsRequest): Promise<runtime.ApiResponse<V1Endpoints>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedEndpoints.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsFromJSON(jsonValue));
    }

    /**
     * partially update the specified Endpoints
     */
    async patchNamespacedEndpoints(requestParameters: PatchNamespacedEndpointsRequest): Promise<V1Endpoints> {
        const response = await this.patchNamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Event
     */
    async patchNamespacedEventRaw(requestParameters: PatchNamespacedEventRequest): Promise<runtime.ApiResponse<V1Event>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedEvent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EventFromJSON(jsonValue));
    }

    /**
     * partially update the specified Event
     */
    async patchNamespacedEvent(requestParameters: PatchNamespacedEventRequest): Promise<V1Event> {
        const response = await this.patchNamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified LimitRange
     */
    async patchNamespacedLimitRangeRaw(requestParameters: PatchNamespacedLimitRangeRequest): Promise<runtime.ApiResponse<V1LimitRange>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedLimitRange.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeFromJSON(jsonValue));
    }

    /**
     * partially update the specified LimitRange
     */
    async patchNamespacedLimitRange(requestParameters: PatchNamespacedLimitRangeRequest): Promise<V1LimitRange> {
        const response = await this.patchNamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified PersistentVolumeClaim
     */
    async patchNamespacedPersistentVolumeClaimRaw(requestParameters: PatchNamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * partially update the specified PersistentVolumeClaim
     */
    async patchNamespacedPersistentVolumeClaim(requestParameters: PatchNamespacedPersistentVolumeClaimRequest): Promise<V1PersistentVolumeClaim> {
        const response = await this.patchNamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     */
    async patchNamespacedPersistentVolumeClaimStatusRaw(requestParameters: PatchNamespacedPersistentVolumeClaimStatusRequest): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     */
    async patchNamespacedPersistentVolumeClaimStatus(requestParameters: PatchNamespacedPersistentVolumeClaimStatusRequest): Promise<V1PersistentVolumeClaim> {
        const response = await this.patchNamespacedPersistentVolumeClaimStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Pod
     */
    async patchNamespacedPodRaw(requestParameters: PatchNamespacedPodRequest): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPod.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * partially update the specified Pod
     */
    async patchNamespacedPod(requestParameters: PatchNamespacedPodRequest): Promise<V1Pod> {
        const response = await this.patchNamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified Pod
     */
    async patchNamespacedPodStatusRaw(requestParameters: PatchNamespacedPodStatusRequest): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedPodStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPodStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedPodStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Pod
     */
    async patchNamespacedPodStatus(requestParameters: PatchNamespacedPodStatusRequest): Promise<V1Pod> {
        const response = await this.patchNamespacedPodStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified PodTemplate
     */
    async patchNamespacedPodTemplateRaw(requestParameters: PatchNamespacedPodTemplateRequest): Promise<runtime.ApiResponse<V1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPodTemplate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateFromJSON(jsonValue));
    }

    /**
     * partially update the specified PodTemplate
     */
    async patchNamespacedPodTemplate(requestParameters: PatchNamespacedPodTemplateRequest): Promise<V1PodTemplate> {
        const response = await this.patchNamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified ReplicationController
     */
    async patchNamespacedReplicationControllerRaw(requestParameters: PatchNamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationController.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * partially update the specified ReplicationController
     */
    async patchNamespacedReplicationController(requestParameters: PatchNamespacedReplicationControllerRequest): Promise<V1ReplicationController> {
        const response = await this.patchNamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update scale of the specified ReplicationController
     */
    async patchNamespacedReplicationControllerScaleRaw(requestParameters: PatchNamespacedReplicationControllerScaleRequest): Promise<runtime.ApiResponse<V1Scale>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationControllerScale.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationControllerScale.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationControllerScale.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ScaleFromJSON(jsonValue));
    }

    /**
     * partially update scale of the specified ReplicationController
     */
    async patchNamespacedReplicationControllerScale(requestParameters: PatchNamespacedReplicationControllerScaleRequest): Promise<V1Scale> {
        const response = await this.patchNamespacedReplicationControllerScaleRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified ReplicationController
     */
    async patchNamespacedReplicationControllerStatusRaw(requestParameters: PatchNamespacedReplicationControllerStatusRequest): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationControllerStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationControllerStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationControllerStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified ReplicationController
     */
    async patchNamespacedReplicationControllerStatus(requestParameters: PatchNamespacedReplicationControllerStatusRequest): Promise<V1ReplicationController> {
        const response = await this.patchNamespacedReplicationControllerStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified ResourceQuota
     */
    async patchNamespacedResourceQuotaRaw(requestParameters: PatchNamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedResourceQuota.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * partially update the specified ResourceQuota
     */
    async patchNamespacedResourceQuota(requestParameters: PatchNamespacedResourceQuotaRequest): Promise<V1ResourceQuota> {
        const response = await this.patchNamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified ResourceQuota
     */
    async patchNamespacedResourceQuotaStatusRaw(requestParameters: PatchNamespacedResourceQuotaStatusRequest): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedResourceQuotaStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedResourceQuotaStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedResourceQuotaStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified ResourceQuota
     */
    async patchNamespacedResourceQuotaStatus(requestParameters: PatchNamespacedResourceQuotaStatusRequest): Promise<V1ResourceQuota> {
        const response = await this.patchNamespacedResourceQuotaStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Secret
     */
    async patchNamespacedSecretRaw(requestParameters: PatchNamespacedSecretRequest): Promise<runtime.ApiResponse<V1Secret>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretFromJSON(jsonValue));
    }

    /**
     * partially update the specified Secret
     */
    async patchNamespacedSecret(requestParameters: PatchNamespacedSecretRequest): Promise<V1Secret> {
        const response = await this.patchNamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Service
     */
    async patchNamespacedServiceRaw(requestParameters: PatchNamespacedServiceRequest): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedService.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * partially update the specified Service
     */
    async patchNamespacedService(requestParameters: PatchNamespacedServiceRequest): Promise<V1Service> {
        const response = await this.patchNamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified ServiceAccount
     */
    async patchNamespacedServiceAccountRaw(requestParameters: PatchNamespacedServiceAccountRequest): Promise<runtime.ApiResponse<V1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedServiceAccount.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * partially update the specified ServiceAccount
     */
    async patchNamespacedServiceAccount(requestParameters: PatchNamespacedServiceAccountRequest): Promise<V1ServiceAccount> {
        const response = await this.patchNamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified Service
     */
    async patchNamespacedServiceStatusRaw(requestParameters: PatchNamespacedServiceStatusRequest): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNamespacedServiceStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedServiceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNamespacedServiceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Service
     */
    async patchNamespacedServiceStatus(requestParameters: PatchNamespacedServiceStatusRequest): Promise<V1Service> {
        const response = await this.patchNamespacedServiceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Node
     */
    async patchNodeRaw(requestParameters: PatchNodeRequest): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNode.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNode.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * partially update the specified Node
     */
    async patchNode(requestParameters: PatchNodeRequest): Promise<V1Node> {
        const response = await this.patchNodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified Node
     */
    async patchNodeStatusRaw(requestParameters: PatchNodeStatusRequest): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchNodeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchNodeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Node
     */
    async patchNodeStatus(requestParameters: PatchNodeStatusRequest): Promise<V1Node> {
        const response = await this.patchNodeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified PersistentVolume
     */
    async patchPersistentVolumeRaw(requestParameters: PatchPersistentVolumeRequest): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchPersistentVolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchPersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * partially update the specified PersistentVolume
     */
    async patchPersistentVolume(requestParameters: PatchPersistentVolumeRequest): Promise<V1PersistentVolume> {
        const response = await this.patchPersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified PersistentVolume
     */
    async patchPersistentVolumeStatusRaw(requestParameters: PatchPersistentVolumeStatusRequest): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchPersistentVolumeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchPersistentVolumeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified PersistentVolume
     */
    async patchPersistentVolumeStatus(requestParameters: PatchPersistentVolumeStatusRequest): Promise<V1PersistentVolume> {
        const response = await this.patchPersistentVolumeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified ComponentStatus
     */
    async readComponentStatusRaw(requestParameters: ReadComponentStatusRequest): Promise<runtime.ApiResponse<V1ComponentStatus>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readComponentStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/componentstatuses/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ComponentStatusFromJSON(jsonValue));
    }

    /**
     * read the specified ComponentStatus
     */
    async readComponentStatus(requestParameters: ReadComponentStatusRequest): Promise<V1ComponentStatus> {
        const response = await this.readComponentStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Namespace
     */
    async readNamespaceRaw(requestParameters: ReadNamespaceRequest): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * read the specified Namespace
     */
    async readNamespace(requestParameters: ReadNamespaceRequest): Promise<V1Namespace> {
        const response = await this.readNamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified Namespace
     */
    async readNamespaceStatusRaw(requestParameters: ReadNamespaceStatusRequest): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespaceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * read status of the specified Namespace
     */
    async readNamespaceStatus(requestParameters: ReadNamespaceStatusRequest): Promise<V1Namespace> {
        const response = await this.readNamespaceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified ConfigMap
     */
    async readNamespacedConfigMapRaw(requestParameters: ReadNamespacedConfigMapRequest): Promise<runtime.ApiResponse<V1ConfigMap>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapFromJSON(jsonValue));
    }

    /**
     * read the specified ConfigMap
     */
    async readNamespacedConfigMap(requestParameters: ReadNamespacedConfigMapRequest): Promise<V1ConfigMap> {
        const response = await this.readNamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Endpoints
     */
    async readNamespacedEndpointsRaw(requestParameters: ReadNamespacedEndpointsRequest): Promise<runtime.ApiResponse<V1Endpoints>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsFromJSON(jsonValue));
    }

    /**
     * read the specified Endpoints
     */
    async readNamespacedEndpoints(requestParameters: ReadNamespacedEndpointsRequest): Promise<V1Endpoints> {
        const response = await this.readNamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Event
     */
    async readNamespacedEventRaw(requestParameters: ReadNamespacedEventRequest): Promise<runtime.ApiResponse<V1Event>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EventFromJSON(jsonValue));
    }

    /**
     * read the specified Event
     */
    async readNamespacedEvent(requestParameters: ReadNamespacedEventRequest): Promise<V1Event> {
        const response = await this.readNamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified LimitRange
     */
    async readNamespacedLimitRangeRaw(requestParameters: ReadNamespacedLimitRangeRequest): Promise<runtime.ApiResponse<V1LimitRange>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeFromJSON(jsonValue));
    }

    /**
     * read the specified LimitRange
     */
    async readNamespacedLimitRange(requestParameters: ReadNamespacedLimitRangeRequest): Promise<V1LimitRange> {
        const response = await this.readNamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified PersistentVolumeClaim
     */
    async readNamespacedPersistentVolumeClaimRaw(requestParameters: ReadNamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * read the specified PersistentVolumeClaim
     */
    async readNamespacedPersistentVolumeClaim(requestParameters: ReadNamespacedPersistentVolumeClaimRequest): Promise<V1PersistentVolumeClaim> {
        const response = await this.readNamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified PersistentVolumeClaim
     */
    async readNamespacedPersistentVolumeClaimStatusRaw(requestParameters: ReadNamespacedPersistentVolumeClaimStatusRequest): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPersistentVolumeClaimStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * read status of the specified PersistentVolumeClaim
     */
    async readNamespacedPersistentVolumeClaimStatus(requestParameters: ReadNamespacedPersistentVolumeClaimStatusRequest): Promise<V1PersistentVolumeClaim> {
        const response = await this.readNamespacedPersistentVolumeClaimStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Pod
     */
    async readNamespacedPodRaw(requestParameters: ReadNamespacedPodRequest): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * read the specified Pod
     */
    async readNamespacedPod(requestParameters: ReadNamespacedPodRequest): Promise<V1Pod> {
        const response = await this.readNamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * read log of the specified Pod
     */
    async readNamespacedPodLogRaw(requestParameters: ReadNamespacedPodLogRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedPodLog.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPodLog.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.follow !== undefined) {
            queryParameters['follow'] = requestParameters.follow;
        }

        if (requestParameters.insecureSkipTLSVerifyBackend !== undefined) {
            queryParameters['insecureSkipTLSVerifyBackend'] = requestParameters.insecureSkipTLSVerifyBackend;
        }

        if (requestParameters.limitBytes !== undefined) {
            queryParameters['limitBytes'] = requestParameters.limitBytes;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.previous !== undefined) {
            queryParameters['previous'] = requestParameters.previous;
        }

        if (requestParameters.sinceSeconds !== undefined) {
            queryParameters['sinceSeconds'] = requestParameters.sinceSeconds;
        }

        if (requestParameters.tailLines !== undefined) {
            queryParameters['tailLines'] = requestParameters.tailLines;
        }

        if (requestParameters.timestamps !== undefined) {
            queryParameters['timestamps'] = requestParameters.timestamps;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/log`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * read log of the specified Pod
     */
    async readNamespacedPodLog(requestParameters: ReadNamespacedPodLogRequest): Promise<string> {
        const response = await this.readNamespacedPodLogRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified Pod
     */
    async readNamespacedPodStatusRaw(requestParameters: ReadNamespacedPodStatusRequest): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedPodStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPodStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * read status of the specified Pod
     */
    async readNamespacedPodStatus(requestParameters: ReadNamespacedPodStatusRequest): Promise<V1Pod> {
        const response = await this.readNamespacedPodStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified PodTemplate
     */
    async readNamespacedPodTemplateRaw(requestParameters: ReadNamespacedPodTemplateRequest): Promise<runtime.ApiResponse<V1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateFromJSON(jsonValue));
    }

    /**
     * read the specified PodTemplate
     */
    async readNamespacedPodTemplate(requestParameters: ReadNamespacedPodTemplateRequest): Promise<V1PodTemplate> {
        const response = await this.readNamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified ReplicationController
     */
    async readNamespacedReplicationControllerRaw(requestParameters: ReadNamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * read the specified ReplicationController
     */
    async readNamespacedReplicationController(requestParameters: ReadNamespacedReplicationControllerRequest): Promise<V1ReplicationController> {
        const response = await this.readNamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * read scale of the specified ReplicationController
     */
    async readNamespacedReplicationControllerScaleRaw(requestParameters: ReadNamespacedReplicationControllerScaleRequest): Promise<runtime.ApiResponse<V1Scale>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationControllerScale.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationControllerScale.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ScaleFromJSON(jsonValue));
    }

    /**
     * read scale of the specified ReplicationController
     */
    async readNamespacedReplicationControllerScale(requestParameters: ReadNamespacedReplicationControllerScaleRequest): Promise<V1Scale> {
        const response = await this.readNamespacedReplicationControllerScaleRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified ReplicationController
     */
    async readNamespacedReplicationControllerStatusRaw(requestParameters: ReadNamespacedReplicationControllerStatusRequest): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationControllerStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationControllerStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * read status of the specified ReplicationController
     */
    async readNamespacedReplicationControllerStatus(requestParameters: ReadNamespacedReplicationControllerStatusRequest): Promise<V1ReplicationController> {
        const response = await this.readNamespacedReplicationControllerStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified ResourceQuota
     */
    async readNamespacedResourceQuotaRaw(requestParameters: ReadNamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * read the specified ResourceQuota
     */
    async readNamespacedResourceQuota(requestParameters: ReadNamespacedResourceQuotaRequest): Promise<V1ResourceQuota> {
        const response = await this.readNamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified ResourceQuota
     */
    async readNamespacedResourceQuotaStatusRaw(requestParameters: ReadNamespacedResourceQuotaStatusRequest): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedResourceQuotaStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedResourceQuotaStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * read status of the specified ResourceQuota
     */
    async readNamespacedResourceQuotaStatus(requestParameters: ReadNamespacedResourceQuotaStatusRequest): Promise<V1ResourceQuota> {
        const response = await this.readNamespacedResourceQuotaStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Secret
     */
    async readNamespacedSecretRaw(requestParameters: ReadNamespacedSecretRequest): Promise<runtime.ApiResponse<V1Secret>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretFromJSON(jsonValue));
    }

    /**
     * read the specified Secret
     */
    async readNamespacedSecret(requestParameters: ReadNamespacedSecretRequest): Promise<V1Secret> {
        const response = await this.readNamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Service
     */
    async readNamespacedServiceRaw(requestParameters: ReadNamespacedServiceRequest): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * read the specified Service
     */
    async readNamespacedService(requestParameters: ReadNamespacedServiceRequest): Promise<V1Service> {
        const response = await this.readNamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified ServiceAccount
     */
    async readNamespacedServiceAccountRaw(requestParameters: ReadNamespacedServiceAccountRequest): Promise<runtime.ApiResponse<V1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * read the specified ServiceAccount
     */
    async readNamespacedServiceAccount(requestParameters: ReadNamespacedServiceAccountRequest): Promise<V1ServiceAccount> {
        const response = await this.readNamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified Service
     */
    async readNamespacedServiceStatusRaw(requestParameters: ReadNamespacedServiceStatusRequest): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNamespacedServiceStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readNamespacedServiceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * read status of the specified Service
     */
    async readNamespacedServiceStatus(requestParameters: ReadNamespacedServiceStatusRequest): Promise<V1Service> {
        const response = await this.readNamespacedServiceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Node
     */
    async readNodeRaw(requestParameters: ReadNodeRequest): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNode.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * read the specified Node
     */
    async readNode(requestParameters: ReadNodeRequest): Promise<V1Node> {
        const response = await this.readNodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified Node
     */
    async readNodeStatusRaw(requestParameters: ReadNodeStatusRequest): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readNodeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * read status of the specified Node
     */
    async readNodeStatus(requestParameters: ReadNodeStatusRequest): Promise<V1Node> {
        const response = await this.readNodeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified PersistentVolume
     */
    async readPersistentVolumeRaw(requestParameters: ReadPersistentVolumeRequest): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readPersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * read the specified PersistentVolume
     */
    async readPersistentVolume(requestParameters: ReadPersistentVolumeRequest): Promise<V1PersistentVolume> {
        const response = await this.readPersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified PersistentVolume
     */
    async readPersistentVolumeStatusRaw(requestParameters: ReadPersistentVolumeStatusRequest): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readPersistentVolumeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * read status of the specified PersistentVolume
     */
    async readPersistentVolumeStatus(requestParameters: ReadPersistentVolumeStatusRequest): Promise<V1PersistentVolume> {
        const response = await this.readPersistentVolumeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Namespace
     */
    async replaceNamespaceRaw(requestParameters: ReplaceNamespaceRequest): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespace.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1NamespaceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace the specified Namespace
     */
    async replaceNamespace(requestParameters: ReplaceNamespaceRequest): Promise<V1Namespace> {
        const response = await this.replaceNamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace finalize of the specified Namespace
     */
    async replaceNamespaceFinalizeRaw(requestParameters: ReplaceNamespaceFinalizeRequest): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespaceFinalize.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespaceFinalize.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/finalize`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1NamespaceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace finalize of the specified Namespace
     */
    async replaceNamespaceFinalize(requestParameters: ReplaceNamespaceFinalizeRequest): Promise<V1Namespace> {
        const response = await this.replaceNamespaceFinalizeRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified Namespace
     */
    async replaceNamespaceStatusRaw(requestParameters: ReplaceNamespaceStatusRequest): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespaceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespaceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1NamespaceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Namespace
     */
    async replaceNamespaceStatus(requestParameters: ReplaceNamespaceStatusRequest): Promise<V1Namespace> {
        const response = await this.replaceNamespaceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified ConfigMap
     */
    async replaceNamespacedConfigMapRaw(requestParameters: ReplaceNamespacedConfigMapRequest): Promise<runtime.ApiResponse<V1ConfigMap>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedConfigMap.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ConfigMapToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapFromJSON(jsonValue));
    }

    /**
     * replace the specified ConfigMap
     */
    async replaceNamespacedConfigMap(requestParameters: ReplaceNamespacedConfigMapRequest): Promise<V1ConfigMap> {
        const response = await this.replaceNamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Endpoints
     */
    async replaceNamespacedEndpointsRaw(requestParameters: ReplaceNamespacedEndpointsRequest): Promise<runtime.ApiResponse<V1Endpoints>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedEndpoints.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1EndpointsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsFromJSON(jsonValue));
    }

    /**
     * replace the specified Endpoints
     */
    async replaceNamespacedEndpoints(requestParameters: ReplaceNamespacedEndpointsRequest): Promise<V1Endpoints> {
        const response = await this.replaceNamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Event
     */
    async replaceNamespacedEventRaw(requestParameters: ReplaceNamespacedEventRequest): Promise<runtime.ApiResponse<V1Event>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedEvent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1EventToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EventFromJSON(jsonValue));
    }

    /**
     * replace the specified Event
     */
    async replaceNamespacedEvent(requestParameters: ReplaceNamespacedEventRequest): Promise<V1Event> {
        const response = await this.replaceNamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified LimitRange
     */
    async replaceNamespacedLimitRangeRaw(requestParameters: ReplaceNamespacedLimitRangeRequest): Promise<runtime.ApiResponse<V1LimitRange>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedLimitRange.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1LimitRangeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeFromJSON(jsonValue));
    }

    /**
     * replace the specified LimitRange
     */
    async replaceNamespacedLimitRange(requestParameters: ReplaceNamespacedLimitRangeRequest): Promise<V1LimitRange> {
        const response = await this.replaceNamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified PersistentVolumeClaim
     */
    async replaceNamespacedPersistentVolumeClaimRaw(requestParameters: ReplaceNamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeClaimToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * replace the specified PersistentVolumeClaim
     */
    async replaceNamespacedPersistentVolumeClaim(requestParameters: ReplaceNamespacedPersistentVolumeClaimRequest): Promise<V1PersistentVolumeClaim> {
        const response = await this.replaceNamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     */
    async replaceNamespacedPersistentVolumeClaimStatusRaw(requestParameters: ReplaceNamespacedPersistentVolumeClaimStatusRequest): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeClaimToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     */
    async replaceNamespacedPersistentVolumeClaimStatus(requestParameters: ReplaceNamespacedPersistentVolumeClaimStatusRequest): Promise<V1PersistentVolumeClaim> {
        const response = await this.replaceNamespacedPersistentVolumeClaimStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Pod
     */
    async replaceNamespacedPodRaw(requestParameters: ReplaceNamespacedPodRequest): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPod.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * replace the specified Pod
     */
    async replaceNamespacedPod(requestParameters: ReplaceNamespacedPodRequest): Promise<V1Pod> {
        const response = await this.replaceNamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified Pod
     */
    async replaceNamespacedPodStatusRaw(requestParameters: ReplaceNamespacedPodStatusRequest): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPodStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPodStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPodStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Pod
     */
    async replaceNamespacedPodStatus(requestParameters: ReplaceNamespacedPodStatusRequest): Promise<V1Pod> {
        const response = await this.replaceNamespacedPodStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified PodTemplate
     */
    async replaceNamespacedPodTemplateRaw(requestParameters: ReplaceNamespacedPodTemplateRequest): Promise<runtime.ApiResponse<V1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPodTemplate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodTemplateToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateFromJSON(jsonValue));
    }

    /**
     * replace the specified PodTemplate
     */
    async replaceNamespacedPodTemplate(requestParameters: ReplaceNamespacedPodTemplateRequest): Promise<V1PodTemplate> {
        const response = await this.replaceNamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified ReplicationController
     */
    async replaceNamespacedReplicationControllerRaw(requestParameters: ReplaceNamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationController.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ReplicationControllerToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * replace the specified ReplicationController
     */
    async replaceNamespacedReplicationController(requestParameters: ReplaceNamespacedReplicationControllerRequest): Promise<V1ReplicationController> {
        const response = await this.replaceNamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace scale of the specified ReplicationController
     */
    async replaceNamespacedReplicationControllerScaleRaw(requestParameters: ReplaceNamespacedReplicationControllerScaleRequest): Promise<runtime.ApiResponse<V1Scale>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationControllerScale.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationControllerScale.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationControllerScale.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ScaleToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ScaleFromJSON(jsonValue));
    }

    /**
     * replace scale of the specified ReplicationController
     */
    async replaceNamespacedReplicationControllerScale(requestParameters: ReplaceNamespacedReplicationControllerScaleRequest): Promise<V1Scale> {
        const response = await this.replaceNamespacedReplicationControllerScaleRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified ReplicationController
     */
    async replaceNamespacedReplicationControllerStatusRaw(requestParameters: ReplaceNamespacedReplicationControllerStatusRequest): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationControllerStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationControllerStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationControllerStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ReplicationControllerToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * replace status of the specified ReplicationController
     */
    async replaceNamespacedReplicationControllerStatus(requestParameters: ReplaceNamespacedReplicationControllerStatusRequest): Promise<V1ReplicationController> {
        const response = await this.replaceNamespacedReplicationControllerStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified ResourceQuota
     */
    async replaceNamespacedResourceQuotaRaw(requestParameters: ReplaceNamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedResourceQuota.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ResourceQuotaToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * replace the specified ResourceQuota
     */
    async replaceNamespacedResourceQuota(requestParameters: ReplaceNamespacedResourceQuotaRequest): Promise<V1ResourceQuota> {
        const response = await this.replaceNamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified ResourceQuota
     */
    async replaceNamespacedResourceQuotaStatusRaw(requestParameters: ReplaceNamespacedResourceQuotaStatusRequest): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedResourceQuotaStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedResourceQuotaStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedResourceQuotaStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ResourceQuotaToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * replace status of the specified ResourceQuota
     */
    async replaceNamespacedResourceQuotaStatus(requestParameters: ReplaceNamespacedResourceQuotaStatusRequest): Promise<V1ResourceQuota> {
        const response = await this.replaceNamespacedResourceQuotaStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Secret
     */
    async replaceNamespacedSecretRaw(requestParameters: ReplaceNamespacedSecretRequest): Promise<runtime.ApiResponse<V1Secret>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1SecretToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretFromJSON(jsonValue));
    }

    /**
     * replace the specified Secret
     */
    async replaceNamespacedSecret(requestParameters: ReplaceNamespacedSecretRequest): Promise<V1Secret> {
        const response = await this.replaceNamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Service
     */
    async replaceNamespacedServiceRaw(requestParameters: ReplaceNamespacedServiceRequest): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedService.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ServiceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * replace the specified Service
     */
    async replaceNamespacedService(requestParameters: ReplaceNamespacedServiceRequest): Promise<V1Service> {
        const response = await this.replaceNamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified ServiceAccount
     */
    async replaceNamespacedServiceAccountRaw(requestParameters: ReplaceNamespacedServiceAccountRequest): Promise<runtime.ApiResponse<V1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedServiceAccount.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ServiceAccountToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * replace the specified ServiceAccount
     */
    async replaceNamespacedServiceAccount(requestParameters: ReplaceNamespacedServiceAccountRequest): Promise<V1ServiceAccount> {
        const response = await this.replaceNamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified Service
     */
    async replaceNamespacedServiceStatusRaw(requestParameters: ReplaceNamespacedServiceStatusRequest): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNamespacedServiceStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedServiceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNamespacedServiceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ServiceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Service
     */
    async replaceNamespacedServiceStatus(requestParameters: ReplaceNamespacedServiceStatusRequest): Promise<V1Service> {
        const response = await this.replaceNamespacedServiceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Node
     */
    async replaceNodeRaw(requestParameters: ReplaceNodeRequest): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNode.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNode.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1NodeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * replace the specified Node
     */
    async replaceNode(requestParameters: ReplaceNodeRequest): Promise<V1Node> {
        const response = await this.replaceNodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified Node
     */
    async replaceNodeStatusRaw(requestParameters: ReplaceNodeStatusRequest): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceNodeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceNodeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1NodeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Node
     */
    async replaceNodeStatus(requestParameters: ReplaceNodeStatusRequest): Promise<V1Node> {
        const response = await this.replaceNodeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified PersistentVolume
     */
    async replacePersistentVolumeRaw(requestParameters: ReplacePersistentVolumeRequest): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replacePersistentVolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replacePersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * replace the specified PersistentVolume
     */
    async replacePersistentVolume(requestParameters: ReplacePersistentVolumeRequest): Promise<V1PersistentVolume> {
        const response = await this.replacePersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified PersistentVolume
     */
    async replacePersistentVolumeStatusRaw(requestParameters: ReplacePersistentVolumeStatusRequest): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replacePersistentVolumeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replacePersistentVolumeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * replace status of the specified PersistentVolume
     */
    async replacePersistentVolumeStatus(requestParameters: ReplacePersistentVolumeStatusRequest): Promise<V1PersistentVolume> {
        const response = await this.replacePersistentVolumeStatusRaw(requestParameters);
        return await response.value();
    }

}
